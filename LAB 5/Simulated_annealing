import random
import math

def print_board(state):
    """Prints the 4x4 board representation with 'Q' and '.'."""
    n = len(state)
    print("Board State:")
    for row in range(n):
        line = ""
        for col in range(n):
            if state[col] == row:
                line += "Q "
            else:
                line += ". "
        print(line)
    print()


def calculate_cost(state):
  
    cost = 0
    n = len(state)
    for i in range(n):
        for j in range(i + 1, n):
            # Check for queens in the same row or on the same diagonal
            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):
                cost += 1
    return cost



def get_all_neighbors(state):
   
    neighbors = []
    n = len(state)
    for i in range(n):
        for j in range(i + 1, n):
            neighbor = state.copy()
            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
            neighbors.append((neighbor, (i, j)))
    return neighbors


def hill_climbing(state):
    
    print("\n--- Starting Hill Climbing ---")
    current_state = state.copy()
    current_cost = calculate_cost(current_state)
    step = 1

    print("Initial State:", current_state, "with Cost:", current_cost)
    print_board(current_state)

    while True:
        print(f"--- Step {step} ---")
        neighbors = get_all_neighbors(current_state)
        neighbor_costs = []

       
        for neighbor, swapped in neighbors:
            cost = calculate_cost(neighbor)
            neighbor_costs.append((cost, neighbor, swapped))

      
        neighbor_costs.sort(key=lambda x: (x[0], x[2][0], x[2][1]))

        best_cost, best_neighbor, best_swap = neighbor_costs[0]

        print(f"Current State: {current_state}, Cost: {current_cost}")
        print(f"Best neighbor is {best_neighbor} with cost {best_cost} (Swap columns {best_swap[0]} & {best_swap[1]})")

        
        if best_cost >= current_cost:
            print("\nNo better neighbor found. Reached a local minimum or plateau.")
            print("Final State:", current_state)
            print_board(current_state)
            print("Final Cost:", current_cost)
            break
        
        
        current_state = best_neighbor
        current_cost = best_cost
        print_board(current_state)

       
        if current_cost == 0:
            print("\nGoal state reached! ðŸ‘‘")
            print("Final State:", current_state)
            print_board(current_state)
            print("Final Cost:", current_cost)
            break
        
        step += 1



def get_random_neighbor(state):
  
    n = len(state)
    neighbor = state.copy()
    # Pick two distinct random columns to swap
    i, j = random.sample(range(n), 2)
    neighbor[i], neighbor[j] = neighbor[j], neighbor[i]
    return neighbor


def simulated_annealing(state, initial_temp=100.0, cooling_rate=0.95, max_steps=1000):
   
    print("\n--- Starting Simulated Annealing ---")
    current_state = state.copy()
    current_cost = calculate_cost(current_state)
    temp = initial_temp

    print("Initial State:", current_state, "with Cost:", current_cost)
    print_board(current_state)

    for step in range(max_steps):
        if temp < 0.01:
            print("\nTemperature cooled down. Algorithm terminated.")
            break

     
        if current_cost == 0:
            print(f"\nGoal state reached in {step+1} steps! ðŸ‘‘")
            break

     
        neighbor_state = get_random_neighbor(current_state)
        neighbor_cost = calculate_cost(neighbor_state)

        
        delta_cost = neighbor_cost - current_cost

      
        if delta_cost < 0:
            print(f"Step {step+1}: Good move. Moved to {neighbor_state} (Cost: {neighbor_cost})")
            current_state = neighbor_state
            current_cost = neighbor_cost
     
        else:
            acceptance_prob = math.exp(-delta_cost / temp)
            if random.random() < acceptance_prob:
                print(f"Step {step+1}: Bad move accepted! Moved to {neighbor_state} (Cost: {neighbor_cost}) with prob {acceptance_prob:.2f}")
                current_state = neighbor_state
                current_cost = neighbor_cost
            else:
                 print(f"Step {step+1}: Bad move rejected. Staying at {current_state} (Cost: {current_cost})")


    
        temp *= cooling_rate

    print("\nFinal State:", current_state)
    print_board(current_state)
    print("Final Cost:", current_cost)


if __name__ == "__main__":
    print("--- 4-Queens Problem Solver ---")
    print("The state is a list of 4 numbers representing the row of the queen in each column.")
    print("For example, '1 3 0 2' means:")
    print(" - Queen in column 0 is in row 1")
    print(" - Queen in column 1 is in row 3")
    print(" - Queen in column 2 is in row 0")
    print(" - Queen in column 3 is in row 2\n")
    
    try:
        initial_state = list(map(int, input("Enter the initial state (e.g., 2 0 3 1): ").split()))
        if len(initial_state) != 4 or not all(0 <= x <= 3 for x in initial_state):
            print("Invalid input. Please enter 4 numbers, each between 0 and 3.")
        else:
            simulated_annealing(initial_state)
           
           
    except ValueError:
        print("Invalid input format. Please enter numbers separated by spaces.")
